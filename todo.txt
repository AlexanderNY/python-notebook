алгоритмы О и о

методы работы со строками

методы работы с массивами
remove() удаляет первое совпадающее значение
li.remove('b')
del удаляет элемент по его индексу
del li[0]
pop() удаляет элемент по индексу и возвращает этот элемент
li.pop(2)

В качестве ключа словаря должен выступать неизменяемый тип данных (числа, строки, кортежи), а в качестве значения может выступать любая структура данных.

методы работы со словарями
d = {'dict': 1, 'dictionary': 2}
d = dict(short='dict', long='dictionary')
d = dict.fromkeys(['a', 'b'], 100)
https://pythonworld.ru/tipy-dannyx-v-python/slovari-dict-funkcii-i-metody-slovarej.html




.get(key,what if there is no key)
 .pop() удаляет из структуры данных элементы, но дополнительно метод возвращает результат — удалённый элемент
.UPDATE()
.GET()
.VALUES()
.keys()
.CLEAR()
.setdefault(ключ и значение по умолчанию, если этого ключа нет в словаре)

словари можно перезаписать, а изменение изменяемых значений внутри - может привести к беде)))
элементы не упорядочены до версии python 3.6

множества
структура данных множество — в нём могут находиться только уникальные элементы
На практике множества используются в случаях, когда надо взять только уникальные элементы из списка, а затем посмотреть только те элементы, которые есть либо в двух множествах, либо в каком-то одном из них.
элементы не упорядочены
Любые неизменяемые типы данных могут быть элементами множества: числа, строки, кортежи.
set1 = set()
set1={1,2,3}
при этом set={} получится dict 

.ADD()
.UPDATE()
тот же add но на несколько элементов
.DISCARD(), .REMOVE()
s1 = {1,2,3,4,5}
s1.remove(10)
# Ошибка KeyError: 10
s1.discard(10)
# Ничего не произошло

.UNION()

.INTERSECTION() берутся все элементы, которые есть одновременно в обоих множествах.
.difference() выбирает все элементы из первого множества, которых нет во втором множестве.

.ISSUBSET() все ли элементы из первого множества есть во втором множестве.


магические методы
.__sizeof__()


типы данных
структуры данных



чтобы создать кортеж с одним элементом, нужно поставить после этого элемента запятую
при создании переменной с запятой в конце строки говорит интерпретатору Python, что создаётся кортеж




Приведение типов
Когда вызывается функция print() на числах, производится неявное преобразование типов в строки. print() не умеет выводить числа — эта функция работает только со строками.
Python не может сложить вместе строку и число

!!!Если попытаться преобразовать число с плавающей точкой, представленное в качестве строки, в целый тип, можно получить ошибку-сначала флоат затем инт

 int() не округляет, а «обрубает» вещественную часть



Условные операторы
<	Меньше. Условие верно, если первый операнд меньше второго
>	Больше. Условие верно, если первый операнд больше второго
<=	Меньше или равно. Условие верно, если первый операнд меньше второго либо равен ему
>=	Больше или равно. Условие верно, если первый операнд больше второго либо равен ему
==	Равенство. Условие верно, если операнды равны
!=	Неравенство. Условие верно, если операнды неравны

побитовые операторы:
|  (Побитовое ИЛИ (OR)),
& (Побитовое И (AND)),
^ (Исключающее ИЛИ (XOR)),
~ (Побитовое отрицание (NOT)),
<< (Побитовый сдвиг влево),
>> (Побитовый сдвиг вправо).


not	Логическое «НЕ»	Возвращает противоположное значение
or	Логическое «ИЛИ»	Возвращает True, если хотя бы одна из переменных True,  (как правило, имеем в виду, что выполнится либо одно условие, либо другое, но никак не оба вместе. Это принцип исключающего «ИЛИ».)
and	Логическое «И»	Возвращает True, если обе переменные True
in, not in	Проверка принадлежности	Возвращает True, если проверяемая переменная содержится/не содержится в последовательности (списке, кортеже, строке...)
is, is not	Проверка тождественности	Возвращает True, если проверяемые объекты эквивалентны/не эквиваленты. То есть переменные ссылаются на один и тот же адрес в памяти компьютера


Приоритет операций
( )	Скобки – высший приоритет – первые
**	Экспонента (возведение в степень)
+x, -x, ~x	Унарные плюс, минус и битовое отрицание
*, /, //, %	Умножение, деления, взятие остатка
+, -	Сложение и вычитание
<<, >>	Битовые сдвиги
&	Битовое И
^	Битовое исключающее ИЛИ (XOR)
|	Битовое ИЛИ
==, !=, >, >=, <, <=,
is, is not,
in, not in	Сравнение, проверка идентичности,
проверка вхождения
not	Логическое НЕ
and	Логическое И
or	Логическое ИЛИ – низший приоритет – последние


!!!
one-liners:
return True if () else False

map()
Python map() — это встроенная функция, которая позволяет обрабатывать и преобразовывать все элементы в итерируемом объекте без использования явного цикла for
Поскольку map() написан на C и сильно оптимизирован, его внутренний подразумеваемый цикл может быть более эффективным, чем обычный цикл for в Python
в Python 3.x. map() возвращает объект map, который является итератором => приходится использовать list
list(map(func(x), list_x))
list(map(func(x,y), list_x, list_y))

zip()


enumerate()
!!!
вопросы для контроля

как работать с итерациями (iterables), циклами, функциями (functions) и лямбда-функций (lambda functions)



Исключения
Ошибки бывают двух видов:

отлавливаемые — всё, что наследуются от класса Exception;
неотлавливаемые — SystemExit, KeyboardInterrupt и т. д.

В блок try помещается «опасный» кусок кода, который может вызывать исключения, в блоке except указывается класс ошибки, которую мы хотим отловить, а затем помещается код, который нужно выполнить в случае возникновения ошибки.

try:
    *код, который может вызвать ту или иную ошибку*
except *ошибка*:
    *код, который выполнится в случае возникновения ошибки*

!опционально обработка других исключений!
except *ошибка*:
    *код, который выполнится в случае возникновения ошибки*

else:
    *код, который выполнится только в случае, если в try ничего не сломалось*
finally:
    *код, который выполнится в любом случае*
!
raise ValueError("Distance or speed cannot be below 0!") 
!
    
    
    
в условии переменная может задаваться диапазоном!
if 6 <= hour < 12:
    print("Morning!") # Утро!
    
тернарный условный оператор — оператор, который записывается в одну строку

a=5
b=6

result = a if a > b else b
print(result)
#ИЛИ
result = (b, a)[a > b]
print(result)



ФОРМАТИРОВАННЫЕ СТРОКИ!!!!!
print("Day {} : {}".format(number, dynamic))


Циклы
BREAK и CONTINUE, PASS

enumerate()
Благодаря функции enumerate() мы можем вести цикл одновременно и по индексам, и по элементам списка.
for index, value in enumerate(iterator):




!!!!
is str or ==str


ФУНКЦИИ

Если вы создадите функцию с повторяющимся названием, вы просто перезапишете её и уже не сможете воспользоваться исходной версией.



в качестве аргументов по умолчанию некорректно использовать изменяемые типы данных: списки, словари, множества
точно можно использовать «простые» типы данных
